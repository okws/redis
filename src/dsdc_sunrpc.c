/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "dsdc_sunrpc.h"
#define DSDC_KEYSIZE 20
#define DSDC_DEFAULT_PORT 30002
#define SHA1SZ 20

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

void *
dsdc_null_1(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_NULL,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

dsdc_res_t *
dsdc_put_1(dsdc_put_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_PUT,
		(xdrproc_t) xdr_dsdc_put_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_remove_1(char *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_REMOVE,
		(xdrproc_t) xdr_dsdc_key_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_get_res_t *
dsdc_get_1(char *argp, CLIENT *clnt)
{
	static dsdc_get_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GET,
		(xdrproc_t) xdr_dsdc_get_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_get_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_mget_res_t *
dsdc_mget_1(dsdc_mget_arg_t *argp, CLIENT *clnt)
{
	static dsdc_mget_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_MGET,
		(xdrproc_t) xdr_dsdc_mget_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_mget_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_register_1(dsdc_register_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_REGISTER,
		(xdrproc_t) xdr_dsdc_register_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_heartbeat_1(void *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_HEARTBEAT,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_newnode_1(dsdcx_slave_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_NEWNODE,
		(xdrproc_t) xdr_dsdcx_slave_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_getstate_res_t *
dsdc_getstate_1(char *argp, CLIENT *clnt)
{
	static dsdc_getstate_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GETSTATE,
		(xdrproc_t) xdr_dsdc_key_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_getstate_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_lock_acquire_res_t *
dsdc_lock_acquire_1(dsdc_lock_acquire_arg_t *argp, CLIENT *clnt)
{
	static dsdc_lock_acquire_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_LOCK_ACQUIRE,
		(xdrproc_t) xdr_dsdc_lock_acquire_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_lock_acquire_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_lock_release_1(dsdc_lock_release_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_LOCK_RELEASE,
		(xdrproc_t) xdr_dsdc_lock_release_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_get_res_t *
dsdc_get2_1(dsdc_req_t *argp, CLIENT *clnt)
{
	static dsdc_get_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GET2,
		(xdrproc_t) xdr_dsdc_req_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_get_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_mget_res_t *
dsdc_mget2_1(dsdc_mget2_arg_t *argp, CLIENT *clnt)
{
	static dsdc_mget_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_MGET2,
		(xdrproc_t) xdr_dsdc_mget2_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_mget_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_get_res_t *
dsdc_get3_1(dsdc_get3_arg_t *argp, CLIENT *clnt)
{
	static dsdc_get_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GET3,
		(xdrproc_t) xdr_dsdc_get3_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_get_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_mget_res_t *
dsdc_mget3_1(dsdc_mget3_arg_t *argp, CLIENT *clnt)
{
	static dsdc_mget_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_MGET3,
		(xdrproc_t) xdr_dsdc_mget3_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_mget_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_put3_1(dsdc_put3_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_PUT3,
		(xdrproc_t) xdr_dsdc_put3_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_slave_statistics_t *
dsdc_get_stats_1(dsdc_get_stats_arg_t *argp, CLIENT *clnt)
{
	static dsdc_slave_statistics_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GET_STATS,
		(xdrproc_t) xdr_dsdc_get_stats_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_slave_statistics_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_get_stats_single_res_t *
dsdc_get_stats_single_1(dsdc_get_stats_single_arg_t *argp, CLIENT *clnt)
{
	static dsdc_get_stats_single_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GET_STATS_SINGLE,
		(xdrproc_t) xdr_dsdc_get_stats_single_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_get_stats_single_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_remove3_1(dsdc_remove3_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_REMOVE3,
		(xdrproc_t) xdr_dsdc_remove3_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
dsdc_set_stats_mode_1(bool_t *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_SET_STATS_MODE,
		(xdrproc_t) xdr_bool, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

dsdc_res_t *
dsdc_put4_1(dsdc_put4_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_PUT4,
		(xdrproc_t) xdr_dsdc_put4_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_res_t *
dsdc_register2_1(dsdc_register2_arg_t *argp, CLIENT *clnt)
{
	static dsdc_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_REGISTER2,
		(xdrproc_t) xdr_dsdc_register2_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dsdc_getstate2_res_t *
dsdc_getstate2_1(char *argp, CLIENT *clnt)
{
	static dsdc_getstate2_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DSDC_GETSTATE2,
		(xdrproc_t) xdr_dsdc_key_t, (caddr_t) argp,
		(xdrproc_t) xdr_dsdc_getstate2_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
aiod2_null_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_NULL,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

int *
aiod2_str_to_file_2(aiod_str_to_file_arg_t *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_STR_TO_FILE,
		(xdrproc_t) xdr_aiod_str_to_file_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

aiod_file_to_str_res_t *
aiod2_file_to_str_2(aiod_file_t *argp, CLIENT *clnt)
{
	static aiod_file_to_str_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_FILE_TO_STR,
		(xdrproc_t) xdr_aiod_file_t, (caddr_t) argp,
		(xdrproc_t) xdr_aiod_file_to_str_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
aiod2_remove_2(aiod_file_t *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_REMOVE,
		(xdrproc_t) xdr_aiod_file_t, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
aiod2_mkdir_2(aiod_mkdir_arg_t *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_MKDIR,
		(xdrproc_t) xdr_aiod_mkdir_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

aiod_statvfs_res_t *
aiod2_statvfs_2(aiod_file_t *argp, CLIENT *clnt)
{
	static aiod_statvfs_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_STATVFS,
		(xdrproc_t) xdr_aiod_file_t, (caddr_t) argp,
		(xdrproc_t) xdr_aiod_statvfs_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

aiod_stat_res_t *
aiod2_stat_2(aiod_file_t *argp, CLIENT *clnt)
{
	static aiod_stat_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_STAT,
		(xdrproc_t) xdr_aiod_file_t, (caddr_t) argp,
		(xdrproc_t) xdr_aiod_stat_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

aiod_glob_res_t *
aiod2_glob_2(aiod_glob_arg_t *argp, CLIENT *clnt)
{
	static aiod_glob_res_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AIOD2_GLOB,
		(xdrproc_t) xdr_aiod_glob_arg_t, (caddr_t) argp,
		(xdrproc_t) xdr_aiod_glob_res_t, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t
xdr_ok_frobber_t (XDR *xdrs, ok_frobber_t *objp)
{

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_id_t (XDR *xdrs, dsdc_id_t *objp)
{

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_statval_t (XDR *xdrs, dsdc_statval_t *objp)
{
	

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_big_statval_t (XDR *xdrs, dsdc_big_statval_t *objp)
{

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_key64_t (XDR *xdrs, dsdc_key64_t *objp)
{

	 if (!xdr_uint32_t (xdrs, &objp->frobber))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->key64))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_uber_key_t (XDR *xdrs, uber_key_t *objp)
{

	 if (!xdr_uint32_t (xdrs, &objp->frobber))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->userid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->load_type))
		 return FALSE;
	return TRUE;
}
#define DSDC_KEYSIZE 20
#define DSDC_DEFAULT_PORT 30002

bool_t
xdr_dsdc_key_t (XDR *xdrs, dsdc_key_t objp)
{

	 if (!xdr_opaque (xdrs, objp, DSDC_KEYSIZE))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_keyset_t (XDR *xdrs, dsdc_keyset_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_keyset_t_val, (u_int *) &objp->dsdc_keyset_t_len, ~0,
		sizeof (dsdc_key_t), (xdrproc_t) xdr_dsdc_key_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_res_t (XDR *xdrs, dsdc_res_t *objp)
{
	

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_annotation_type_t (XDR *xdrs, dsdc_annotation_type_t *objp)
{
	

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_annotation_t (XDR *xdrs, dsdc_annotation_t *objp)
{
	

	 if (!xdr_dsdc_annotation_type_t (xdrs, &objp->typ))
		 return FALSE;
	switch (objp->typ) {
	case DSDC_INT_ANNOTATION:
		 if (!xdr_int (xdrs, &objp->dsdc_annotation_t_u.i))
			 return FALSE;
		break;
	case DSDC_CUPID_ANNOTATION:
		 if (!xdr_ok_frobber_t (xdrs, &objp->dsdc_annotation_t_u.frobber))
			 return FALSE;
		break;
	case DSDC_STR_ANNOTATION:
		 if (!xdr_string (xdrs, &objp->dsdc_annotation_t_u.s, ~0))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dsdc_histogram_t (XDR *xdrs, dsdc_histogram_t *objp)
{
	

	 if (!xdr_quad_t (xdrs, &objp->scale_factor))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->samples))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->avg))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->min))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->max))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->buckets.buckets_val, (u_int *) &objp->buckets.buckets_len, ~0,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->total))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_dataset_t (XDR *xdrs, dsdc_dataset_t *objp)
{
	

	 if (!xdr_quad_t (xdrs, &objp->creations))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->puts))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->missed_gets))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->missed_removes))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->rm_explicit))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->rm_make_room))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->rm_clean))
		 return FALSE;
	 if (!xdr_quad_t (xdrs, &objp->rm_replace))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->duration))
		 return FALSE;
	 if (!xdr_dsdc_histogram_t (xdrs, &objp->gets))
		 return FALSE;
	 if (!xdr_dsdc_histogram_t (xdrs, &objp->objsz))
		 return FALSE;
	 if (!xdr_dsdc_histogram_t (xdrs, &objp->do_gets))
		 return FALSE;
	 if (!xdr_dsdc_histogram_t (xdrs, &objp->do_lifetime))
		 return FALSE;
	 if (!xdr_dsdc_histogram_t (xdrs, &objp->do_objsz))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->lifetime, sizeof (dsdc_histogram_t), (xdrproc_t) xdr_dsdc_histogram_t))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->n_active, sizeof (quad_t), (xdrproc_t) xdr_quad_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_statistic_t (XDR *xdrs, dsdc_statistic_t *objp)
{
	

	 if (!xdr_dsdc_annotation_t (xdrs, &objp->annotation))
		 return FALSE;
	 if (!xdr_dsdc_dataset_t (xdrs, &objp->epoch_data))
		 return FALSE;
	 if (!xdr_dsdc_dataset_t (xdrs, &objp->alltime_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_statistics_t (XDR *xdrs, dsdc_statistics_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_statistics_t_val, (u_int *) &objp->dsdc_statistics_t_len, ~0,
		sizeof (dsdc_statistic_t), (xdrproc_t) xdr_dsdc_statistic_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_dataset_params_t (XDR *xdrs, dsdc_dataset_params_t *objp)
{
	

	 if (!xdr_u_int (xdrs, &objp->lifetime_n_buckets))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->gets_n_buckets))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->objsz_n_buckets))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_get_stats_single_arg_t (XDR *xdrs, dsdc_get_stats_single_arg_t *objp)
{
	

	 if (!xdr_dsdc_dataset_params_t (xdrs, &objp->params))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_hostname_t (XDR *xdrs, dsdc_hostname_t *objp)
{
	

	 if (!xdr_string (xdrs, objp, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_hostnames_t (XDR *xdrs, dsdc_hostnames_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_hostnames_t_val, (u_int *) &objp->dsdc_hostnames_t_len, ~0,
		sizeof (dsdc_hostname_t), (xdrproc_t) xdr_dsdc_hostname_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_settype_t (XDR *xdrs, dsdc_settype_t *objp)
{
	

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_slaveset_t (XDR *xdrs, dsdc_slaveset_t *objp)
{
	

	 if (!xdr_dsdc_settype_t (xdrs, &objp->typ))
		 return FALSE;
	switch (objp->typ) {
	case DSDC_SET_SOME:
		 if (!xdr_dsdc_hostnames_t (xdrs, &objp->dsdc_slaveset_t_u.some))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dsdc_get_stats_arg_t (XDR *xdrs, dsdc_get_stats_arg_t *objp)
{
	

	 if (!xdr_dsdc_slaveset_t (xdrs, &objp->hosts))
		 return FALSE;
	 if (!xdr_dsdc_get_stats_single_arg_t (xdrs, &objp->getparams))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_get_stats_single_res_t (XDR *xdrs, dsdc_get_stats_single_res_t *objp)
{
	

	 if (!xdr_dsdc_res_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case DSDC_OK:
		 if (!xdr_dsdc_statistics_t (xdrs, &objp->dsdc_get_stats_single_res_t_u.stats))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dsdc_slave_statistic_t (XDR *xdrs, dsdc_slave_statistic_t *objp)
{
	

	 if (!xdr_dsdc_hostname_t (xdrs, &objp->host))
		 return FALSE;
	 if (!xdr_dsdc_get_stats_single_res_t (xdrs, &objp->stats))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_slave_statistics_t (XDR *xdrs, dsdc_slave_statistics_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_slave_statistics_t_val, (u_int *) &objp->dsdc_slave_statistics_t_len, ~0,
		sizeof (dsdc_slave_statistic_t), (xdrproc_t) xdr_dsdc_slave_statistic_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_req_t (XDR *xdrs, dsdc_req_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->time_to_expire))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_custom_t (XDR *xdrs, dsdc_custom_t *objp)
{
	

	 if (!xdr_bytes (xdrs, (char **)&objp->dsdc_custom_t_val, (u_int *) &objp->dsdc_custom_t_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_key_template_t (XDR *xdrs, dsdc_key_template_t *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->pid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->port))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->id);
		IXDR_PUT_U_LONG(buf, objp->pid);
		IXDR_PUT_U_LONG(buf, objp->port);
		}
		 if (!xdr_string (xdrs, &objp->hostname, ~0))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->pid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->port))
				 return FALSE;

		} else {
		objp->id = IXDR_GET_U_LONG(buf);
		objp->pid = IXDR_GET_U_LONG(buf);
		objp->port = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_string (xdrs, &objp->hostname, ~0))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->pid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->hostname, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_obj_t (XDR *xdrs, dsdc_obj_t *objp)
{

	 if (!xdr_bytes (xdrs, (char **)&objp->dsdc_obj_t_val, (u_int *) &objp->dsdc_obj_t_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_put_arg_t (XDR *xdrs, dsdc_put_arg_t *objp)
{

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_dsdc_obj_t (xdrs, &objp->obj))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_get_res_t (XDR *xdrs, dsdc_get_res_t *objp)
{

	 if (!xdr_dsdc_res_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case DSDC_OK:
		 if (!xdr_dsdc_obj_t (xdrs, &objp->dsdc_get_res_t_u.obj))
			 return FALSE;
		break;
	case DSDC_RPC_ERROR:
		 if (!xdr_u_int (xdrs, &objp->dsdc_get_res_t_u.err))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dsdc_mget_1res_t (XDR *xdrs, dsdc_mget_1res_t *objp)
{

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_dsdc_get_res_t (xdrs, &objp->res))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_mget_res_t (XDR *xdrs, dsdc_mget_res_t *objp)
{

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_mget_res_t_val, (u_int *) &objp->dsdc_mget_res_t_len, ~0,
		sizeof (dsdc_mget_1res_t), (xdrproc_t) xdr_dsdc_mget_1res_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_mget_arg_t (XDR *xdrs, dsdc_mget_arg_t *objp)
{

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_mget_arg_t_val, (u_int *) &objp->dsdc_mget_arg_t_len, ~0,
		sizeof (dsdc_key_t), (xdrproc_t) xdr_dsdc_key_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_mget2_arg_t (XDR *xdrs, dsdc_mget2_arg_t *objp)
{

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_mget2_arg_t_val, (u_int *) &objp->dsdc_mget2_arg_t_len, ~0,
		sizeof (dsdc_req_t), (xdrproc_t) xdr_dsdc_req_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_get_arg_t (XDR *xdrs, dsdc_get_arg_t objp)
{

	 if (!xdr_dsdc_key_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_get3_arg_t (XDR *xdrs, dsdc_get3_arg_t *objp)
{

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->time_to_expire))
		 return FALSE;
	 if (!xdr_dsdc_annotation_t (xdrs, &objp->annotation))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_mget3_arg_t (XDR *xdrs, dsdc_mget3_arg_t *objp)
{

	 if (!xdr_array (xdrs, (char **)&objp->dsdc_mget3_arg_t_val, (u_int *) &objp->dsdc_mget3_arg_t_len, ~0,
		sizeof (dsdc_get3_arg_t), (xdrproc_t) xdr_dsdc_get3_arg_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_put3_arg_t (XDR *xdrs, dsdc_put3_arg_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_dsdc_obj_t (xdrs, &objp->obj))
		 return FALSE;
	 if (!xdr_dsdc_annotation_t (xdrs, &objp->annotation))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_cksum_t (XDR *xdrs, dsdc_cksum_t objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_put4_arg_t (XDR *xdrs, dsdc_put4_arg_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_dsdc_obj_t (xdrs, &objp->obj))
		 return FALSE;
	 if (!xdr_dsdc_annotation_t (xdrs, &objp->annotation))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->checksum, sizeof (dsdc_cksum_t), (xdrproc_t) xdr_dsdc_cksum_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_remove3_arg_t (XDR *xdrs, dsdc_remove3_arg_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_dsdc_annotation_t (xdrs, &objp->annotation))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_slave_type_t (XDR *xdrs, dsdc_slave_type_t *objp)
{
	

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdcx_slave_t (XDR *xdrs, dsdcx_slave_t *objp)
{
	

	 if (!xdr_dsdc_keyset_t (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->hostname, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdcx_slave2_t (XDR *xdrs, dsdcx_slave2_t *objp)
{
	

	 if (!xdr_dsdc_keyset_t (xdrs, &objp->keys))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->hostname, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_dsdc_slave_type_t (xdrs, &objp->slave_type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdcx_state_t (XDR *xdrs, dsdcx_state_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->slaves.slaves_val, (u_int *) &objp->slaves.slaves_len, ~0,
		sizeof (dsdcx_slave_t), (xdrproc_t) xdr_dsdcx_slave_t))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->lock_server, sizeof (dsdcx_slave_t), (xdrproc_t) xdr_dsdcx_slave_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdcx_state2_t (XDR *xdrs, dsdcx_state2_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->slaves.slaves_val, (u_int *) &objp->slaves.slaves_len, ~0,
		sizeof (dsdcx_slave2_t), (xdrproc_t) xdr_dsdcx_slave2_t))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->lock_server, sizeof (dsdcx_slave_t), (xdrproc_t) xdr_dsdcx_slave_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_register_arg_t (XDR *xdrs, dsdc_register_arg_t *objp)
{
	

	 if (!xdr_dsdcx_slave_t (xdrs, &objp->slave))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->primary))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->lock_server))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_register2_arg_t (XDR *xdrs, dsdc_register2_arg_t *objp)
{
	

	 if (!xdr_dsdcx_slave2_t (xdrs, &objp->slave))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->primary))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->lock_server))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_getstate_res_t (XDR *xdrs, dsdc_getstate_res_t *objp)
{
	

	 if (!xdr_bool (xdrs, &objp->needupdate))
		 return FALSE;
	switch (objp->needupdate) {
	case TRUE:
		 if (!xdr_dsdcx_state_t (xdrs, &objp->dsdc_getstate_res_t_u.state))
			 return FALSE;
		break;
	case FALSE:
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_dsdc_getstate2_res_t (XDR *xdrs, dsdc_getstate2_res_t *objp)
{
	

	 if (!xdr_bool (xdrs, &objp->needupdate))
		 return FALSE;
	switch (objp->needupdate) {
	case TRUE:
		 if (!xdr_dsdcx_state2_t (xdrs, &objp->dsdc_getstate2_res_t_u.state))
			 return FALSE;
		break;
	case FALSE:
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_dsdc_lock_acquire_res_t (XDR *xdrs, dsdc_lock_acquire_res_t *objp)
{
	

	 if (!xdr_dsdc_res_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case DSDC_OK:
		 if (!xdr_u_quad_t (xdrs, &objp->dsdc_lock_acquire_res_t_u.lockid))
			 return FALSE;
		break;
	case DSDC_RPC_ERROR:
		 if (!xdr_u_int (xdrs, &objp->dsdc_lock_acquire_res_t_u.err))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dsdc_lock_acquire_arg_t (XDR *xdrs, dsdc_lock_acquire_arg_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->writer))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->block))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->timeout))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dsdc_lock_release_arg_t (XDR *xdrs, dsdc_lock_release_arg_t *objp)
{
	

	 if (!xdr_dsdc_key_t (xdrs, objp->key))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->lockid))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_file_t (XDR *xdrs, aiod_file_t *objp)
{
	

	 if (!xdr_string (xdrs, objp, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_files_t (XDR *xdrs, aiod_files_t *objp)
{
	

	 if (!xdr_array (xdrs, (char **)&objp->aiod_files_t_val, (u_int *) &objp->aiod_files_t_len, ~0,
		sizeof (aiod_file_t), (xdrproc_t) xdr_aiod_file_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_str_to_file_arg_t (XDR *xdrs, aiod_str_to_file_arg_t *objp)
{
	

	register int32_t *buf;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_aiod_file_t (xdrs, &objp->file))
			 return FALSE;
		 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->flags))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->sync))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->canfail))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->atomic))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->flags);
			IXDR_PUT_LONG(buf, objp->mode);
			IXDR_PUT_BOOL(buf, objp->sync);
			IXDR_PUT_BOOL(buf, objp->canfail);
			IXDR_PUT_BOOL(buf, objp->atomic);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_aiod_file_t (xdrs, &objp->file))
			 return FALSE;
		 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->flags))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->mode))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->sync))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->canfail))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->atomic))
				 return FALSE;
		} else {
			objp->flags = IXDR_GET_LONG(buf);
			objp->mode = IXDR_GET_LONG(buf);
			objp->sync = IXDR_GET_BOOL(buf);
			objp->canfail = IXDR_GET_BOOL(buf);
			objp->atomic = IXDR_GET_BOOL(buf);
		}
	 return TRUE;
	}

	 if (!xdr_aiod_file_t (xdrs, &objp->file))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->flags))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->mode))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->sync))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->canfail))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->atomic))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_file_to_str_res_t (XDR *xdrs, aiod_file_to_str_res_t *objp)
{
	

	 if (!xdr_int (xdrs, &objp->code))
		 return FALSE;
	switch (objp->code) {
	case 0:
		 if (!xdr_bytes (xdrs, (char **)&objp->aiod_file_to_str_res_t_u.data.data_val, (u_int *) &objp->aiod_file_to_str_res_t_u.data.data_len, ~0))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_aiod_mkdir_arg_t (XDR *xdrs, aiod_mkdir_arg_t *objp)
{
	

	 if (!xdr_aiod_file_t (xdrs, &objp->file))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->mode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_glob_res_t (XDR *xdrs, aiod_glob_res_t *objp)
{
	

	 if (!xdr_int (xdrs, &objp->code))
		 return FALSE;
	switch (objp->code) {
	case 0:
		 if (!xdr_aiod_files_t (xdrs, &objp->aiod_glob_res_t_u.files))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_aiod_glob_arg_t (XDR *xdrs, aiod_glob_arg_t *objp)
{
	

	 if (!xdr_aiod_file_t (xdrs, &objp->dir))
		 return FALSE;
	 if (!xdr_aiod_file_t (xdrs, &objp->pattern))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_statvfs_t (XDR *xdrs, aiod_statvfs_t *objp)
{
	

	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_bsize))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_frsize))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_blocks))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_bfree))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_bavail))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_files))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_ffree))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_favail))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_fsid))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_flag))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_f_namemax))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_stat_t (XDR *xdrs, aiod_stat_t *objp)
{
	

	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_dev))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_ino))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_mode))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_nlink))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_uid))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_gid))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_rdev))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_size))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_blksize))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_blocks))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_atime))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_mtime))
		 return FALSE;
	 if (!xdr_u_quad_t (xdrs, &objp->aiod_st_ctime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_aiod_stat_res_t (XDR *xdrs, aiod_stat_res_t *objp)
{
	

	 if (!xdr_int (xdrs, &objp->code))
		 return FALSE;
	switch (objp->code) {
	case 0:
		 if (!xdr_aiod_stat_t (xdrs, &objp->aiod_stat_res_t_u.stat))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_aiod_statvfs_res_t (XDR *xdrs, aiod_statvfs_res_t *objp)
{
	

	 if (!xdr_int (xdrs, &objp->code))
		 return FALSE;
	switch (objp->code) {
	case 0:
		 if (!xdr_aiod_statvfs_t (xdrs, &objp->aiod_statvfs_res_t_u.stat))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
#define SHA1SZ 20

bool_t
xdr_checksum_t (XDR *xdrs, checksum_t objp)
{
	

	 if (!xdr_opaque (xdrs, objp, SHA1SZ))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fscache_file_data_t (XDR *xdrs, fscache_file_data_t *objp)
{
	

	 if (!xdr_u_int (xdrs, &objp->timestamp))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fscache_file_t (XDR *xdrs, fscache_file_t *objp)
{
	

	 if (!xdr_checksum_t (xdrs, objp->checksum))
		 return FALSE;
	 if (!xdr_fscache_file_data_t (xdrs, &objp->data))
		 return FALSE;
	return TRUE;
}
